from secp256k1 import *
from web3 import Web3 as w3
from sqrtmod import modular_sqrt
from rlp import encode

def pubFromPrivKey(priv_key: str) -> Point:
    return (int(priv_key, 16) * G)

def addrFromPubKey(pub_key: Point) -> str:
    return '0x' + w3.keccak(hexstr=pub_key.__repr__()).hex()[-40:]

def addrFromPrivKey(priv_key: str) -> str:
    return '0x' + w3.keccak(hexstr=pubFromPrivKey(priv_key).__repr__()).hex()[-40:]

def yValCurve(x: int) -> int:
    return modular_sqrt(x**3 + 7, P)


# TESTING
priv1 = '0xc6161dd36d7e176f83e77c2e6794001b15900692c3f8520b3cec8be760d74feb'
pub1 = '0x9ed4b7ecc3de540d5c45aba2cf11e04d4162f4d17eec3d3f177aa8c8c1fdc117f7f67ea5dc1796f62683a045f7a520fa44ae87ed66b4ba24401ba6bec74bfb30'
addr1 = '0x36fc93d7cea2140c2c08c792ead73068508ac59d'

assert pub1 == pubFromPrivKey(priv1).__repr__()
assert addr1 == addrFromPubKey(pubFromPrivKey(priv1))
assert addr1 == addrFromPrivKey(priv1) == addr1


# Capture the Ether: Public Key

tx = {

    "blockHash": "0x487183cd9eed0970dab843c9ebd577e6af3e1eb7c9809d240c8735eab7cb43de",

    "blockNumber": 3015083,

    "hash": "0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb",

    "from": "0x92b28647Ae1F3264661f72fb2eB9625A89D88A31",

    "gas": 90000,

    "gasPrice": 1000000000,

    "input": "0x5468616e6b732c206d616e21",

    "nonce": 0,

    "r": "0xa5522718c0f95dde27f0827f55de836342ceda594d20458523dd71a539d52ad7",

    "s": "0x5710e64311d481764b5ae8ca691b05d14054782c7d489f3511a7abf2f5078962",

    "to": "0x6B477781b0e68031109f21887e6B5afEAaEB002b",

    "transactionIndex": 7,

    "v": 41, # chain id is 3, parity of y must be 0

    "value": 0

}

r = int(tx['r'], 16)
s = int(tx['s'], 16)

# Elliptic curve point
y = -yValCurve(r) % P # take the additive inverse since v is odd
R = Point(r, y, secp256k1)

# Calculation performed mod N (prime order of the group generated by G)
r_inv = (FieldElement(r, PrimeGaloisField(N)) ** -1).value
assert r_inv < N and r * r_inv % N == 1

# rlp encode the message (chain id is 3)
signingData = [tx['nonce'], tx['gasPrice'], tx['gas'], bytes.fromhex(tx['to'][2:]), tx['value'], bytes.fromhex(tx['input'][2:]), 3, 0, 0]
z = int(w3.keccak(encode(signingData)).hex(), 16)
assert z < N

# see https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Public_key_recovery
u1 = (-z * r_inv) % N
u2 = (s * r_inv) % N

# public key
K = u1*G + u2*R

assert w3.toChecksumAddress(addrFromPubKey(K)) == tx['from']
print("Public Key challenge successfully passed")


# Capture the Ether: Account Takeover

tx1 = {

    "blockHash": "0x0515b2216fa8012618c330bff363d7a49876f4b0f05752b17b01597b5527a604",

    "blockNumber": 3015063,

    "hash": "0xd79fc80e7b787802602f3317b7fe67765c14a7d40c3e0dcb266e63657f881396",

    "from": "0x6B477781b0e68031109f21887e6B5afEAaEB002b",

    "gas": 21000,

    "gasPrice": 1000000000,

    "input": "0x",

    "nonce": 0,

    "r": "0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166",

    "s": "0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8",

    "to": "0x92b28647Ae1F3264661f72fb2eB9625A89D88A31",

    "transactionIndex": 9,

    "v": 41,

    "value": 1230000000000000000

}

tx2 = {

    "blockHash": "0xe23306ce25e2e0329ed148f17e16b3b566b2b42cb86bf4ece5b41a0fee30a497",

    "blockNumber": 3015068,

    "hash": "0x061bf0b4b5fdb64ac475795e9bc5a3978f985919ce6747ce2cfbbcaccaf51009",

    "from": "0x6B477781b0e68031109f21887e6B5afEAaEB002b",

    "gas": 21000,

    "gasPrice": 1000000000,

    "input": "0x",

    "nonce": 1,

    "r": "0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166",

    "s": "0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de",

    "to": "0x92b28647Ae1F3264661f72fb2eB9625A89D88A31",

    "transactionIndex": 17,

    "v": 41,

    "value": 1811266580600000000

}

r1 = int(tx1['r'], 16) # == r2
s1 = int(tx1['s'], 16)
s2 = int(tx2['s'], 16)

signingData1 = [tx1['nonce'], tx1['gasPrice'], tx1['gas'], bytes.fromhex(tx1['to'][2:]), tx1['value'], bytes.fromhex(tx1['input'][2:]), 3, 0, 0]
signingData2 = [tx2['nonce'], tx2['gasPrice'], tx2['gas'], bytes.fromhex(tx2['to'][2:]), tx2['value'], bytes.fromhex(tx2['input'][2:]), 3, 0, 0]

# get the message hashes
z1 = int(w3.keccak(encode(signingData1)).hex(), 16)
z2 = int(w3.keccak(encode(signingData2)).hex(), 16)
assert z1 < N and z2 < N

# inverse of difference of s values
sd = (s1 - s2) % N
sd_inv = (FieldElement(sd, PrimeGaloisField(N)) ** -1).value
assert sd_inv < N and sd * sd_inv % N == 1

# ephemeral private key
k = (z1-z2) * sd_inv % N

# inverse of r
r1_inv = (FieldElement(r1, PrimeGaloisField(N)) ** -1).value
assert r1_inv < N and r1 * r1_inv % N == 1

# account private key
d = (s1*k - z1) * r1_inv % N

assert w3.toChecksumAddress(addrFromPrivKey(hex(d))) == tx1['from']
print("Account Takeover challenge successfully passed")

